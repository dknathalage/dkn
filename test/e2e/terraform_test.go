package e2e

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/dknathalage/dkn/pkg/plugins/terraform"
)

func TestTerraformPlugin_Generate(t *testing.T) {
	// Set test mode environment variable
	t.Setenv("GO_TEST_MODE", "1")
	
	tempDir := t.TempDir()

	configContent := `components:
  - webapi
  - database
environments:
  - dev
  - staging
  - prod`

	terraformDir := filepath.Join(tempDir, "terraform")
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		t.Fatalf("Failed to create terraform directory: %v", err)
	}
	configPath := filepath.Join(terraformDir, "terraform.yaml")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		t.Fatalf("Failed to write test config: %v", err)
	}

	plugin := terraform.New()
	ctx := context.Background()

	err := plugin.Generate(ctx, configPath, tempDir)
	if err != nil {
		t.Fatalf("Failed to generate terraform config: %v", err)
	}

	terraformOutputDir := filepath.Join(tempDir, "terraform")

	for _, component := range []string{"webapi", "database"} {
		componentDir := filepath.Join(terraformOutputDir, component)

		expectedFiles := []string{
			"variables.tf",
			"provider.tf",
			"backend.tf",
			"Taskfile.yaml",
			".gitignore",
		}

		for _, file := range expectedFiles {
			filePath := filepath.Join(componentDir, file)
			if _, err := os.Stat(filePath); os.IsNotExist(err) {
				t.Errorf("Expected file %s does not exist", filePath)
			}
		}

		tfvarsDir := filepath.Join(componentDir, "tfvars")
		for _, env := range []string{"dev", "staging", "prod"} {
			tfvarsFile := filepath.Join(tfvarsDir, env+".tfvars")
			if _, err := os.Stat(tfvarsFile); os.IsNotExist(err) {
				t.Errorf("Expected tfvars file %s does not exist", tfvarsFile)
			}
		}
	}
}

func TestTerraformPlugin_GeneratedContent(t *testing.T) {
	// Set test mode environment variable
	t.Setenv("GO_TEST_MODE", "1")
	
	tempDir := t.TempDir()

	configContent := `components:
  - testcomp
environments:
  - testenv`

	terraformDir := filepath.Join(tempDir, "terraform")
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		t.Fatalf("Failed to create terraform directory: %v", err)
	}
	configPath := filepath.Join(terraformDir, "terraform.yaml")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		t.Fatalf("Failed to write test config: %v", err)
	}

	plugin := terraform.New()
	ctx := context.Background()

	err := plugin.Generate(ctx, configPath, tempDir)
	if err != nil {
		t.Fatalf("Failed to generate terraform config: %v", err)
	}

	componentDir := filepath.Join(tempDir, "terraform", "testcomp")

	variablesTfContent, err := os.ReadFile(filepath.Join(componentDir, "variables.tf"))
	if err != nil {
		t.Fatalf("Failed to read variables.tf: %v", err)
	}

	if !contains(string(variablesTfContent), "# autogenerated") {
		t.Error("variables.tf should contain autogenerated comment")
	}

	if !contains(string(variablesTfContent), "project_name") {
		t.Error("variables.tf should contain project_name variable")
	}

	if !contains(string(variablesTfContent), "component_name") {
		t.Error("variables.tf should contain component_name variable")
	}

	if !contains(string(variablesTfContent), "testcomp") {
		t.Error("variables.tf should contain component default value")
	}

	if !contains(string(variablesTfContent), "environment") {
		t.Error("variables.tf should contain environment variable")
	}

	tfvarsContent, err := os.ReadFile(filepath.Join(componentDir, "tfvars", "testenv.tfvars"))
	if err != nil {
		t.Fatalf("Failed to read testenv.tfvars: %v", err)
	}

	if !contains(string(tfvarsContent), "testcomp") {
		t.Error("tfvars should contain component name")
	}

	if !contains(string(tfvarsContent), "testenv") {
		t.Error("tfvars should contain environment name")
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) &&
		(s == substr ||
			len(s) > len(substr) &&
				(s[:len(substr)] == substr ||
					s[len(s)-len(substr):] == substr ||
					findInString(s, substr)))
}

func findInString(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
