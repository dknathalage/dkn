package terraform

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"
)

type TerraformPlugin struct{}

type TerraformConfig struct {
	Components   []string `yaml:"components"`
	Environments []string `yaml:"environments"`
}

type GenerateContext struct {
	Component    string
	Environments []string
	OutputDir    string
	Org          string
	Repo         string
}

func New() *TerraformPlugin {
	return &TerraformPlugin{}
}

func (p *TerraformPlugin) Name() string {
	return "terraform"
}

func (p *TerraformPlugin) ConfigFile() string {
	return "terraform/terraform.yaml"
}

func (p *TerraformPlugin) Generate(ctx context.Context, configPath string, outputDir string) error {
	config, err := p.loadConfig(configPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	terraformDir := filepath.Join(outputDir, "terraform")
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		return fmt.Errorf("failed to create terraform directory: %w", err)
	}

	org, repo, err := p.getOrgAndRepo()
	if err != nil {
		return fmt.Errorf("failed to get org/repo: %w", err)
	}

	for _, component := range config.Components {
		ctx := &GenerateContext{
			Component:    component,
			Environments: config.Environments,
			OutputDir:    terraformDir,
			Org:          org,
			Repo:         repo,
		}
		if err := p.generateComponent(ctx); err != nil {
			return fmt.Errorf("failed to generate component %s: %w", component, err)
		}
	}

	fmt.Printf("âœ… Generated Terraform configuration in %s\n", terraformDir)
	return nil
}

func (p *TerraformPlugin) loadConfig(configPath string) (*TerraformConfig, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, err
	}

	var config TerraformConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

func (p *TerraformPlugin) getOrgAndRepo() (string, string, error) {
	// Check if we're in a testing environment
	if os.Getenv("GO_TEST_MODE") != "" {
		return "test-org", "test-repo", nil
	}

	cmd := exec.Command("git", "remote", "get-url", "origin")
	output, err := cmd.Output()
	if err != nil {
		return "", "", fmt.Errorf("git remote origin is not set. Please set up your git remote origin or use 'gh repo create' to create and connect a GitHub repository")
	}

	remoteURL := strings.TrimSpace(string(output))

	// Handle both SSH and HTTPS formats
	// SSH: git@github.com:org/repo.git
	// HTTPS: https://github.com/org/repo.git
	var org, repo string

	if strings.HasPrefix(remoteURL, "git@") {
		// SSH format
		re := regexp.MustCompile(`git@[^:]+:([^/]+)/(.+)\.git$`)
		matches := re.FindStringSubmatch(remoteURL)
		if len(matches) == 3 {
			org = matches[1]
			repo = matches[2]
		}
	} else if strings.HasPrefix(remoteURL, "https://") {
		// HTTPS format
		re := regexp.MustCompile(`https://[^/]+/([^/]+)/(.+)\.git$`)
		matches := re.FindStringSubmatch(remoteURL)
		if len(matches) == 3 {
			org = matches[1]
			repo = matches[2]
		}
	}

	if org == "" || repo == "" {
		return "", "", fmt.Errorf("unable to parse git remote URL '%s'. Please ensure your git remote origin is set to a valid GitHub repository URL, or use 'gh repo create' to set up your repository", remoteURL)
	}

	return org, repo, nil
}

func (p *TerraformPlugin) generateComponent(ctx *GenerateContext) error {
	componentDir := filepath.Join(ctx.OutputDir, ctx.Component)
	if err := os.MkdirAll(componentDir, 0755); err != nil {
		return err
	}

	tfvarsDir := filepath.Join(componentDir, "tfvars")
	if err := os.MkdirAll(tfvarsDir, 0755); err != nil {
		return err
	}

	ctx.OutputDir = componentDir

	if err := p.generateVariablesTf(ctx); err != nil {
		return err
	}

	if err := p.generateProviderTf(ctx); err != nil {
		return err
	}

	if err := p.generateBackendTf(ctx); err != nil {
		return err
	}

	if err := p.generateTaskfile(ctx); err != nil {
		return err
	}

	if err := p.generateGitignore(ctx); err != nil {
		return err
	}

	for _, env := range ctx.Environments {
		if err := p.generateTfvars(ctx, env, tfvarsDir); err != nil {
			return err
		}
	}

	return nil
}

func (p *TerraformPlugin) generateGitignore(ctx *GenerateContext) error {
	content := `.terraform
.terraform*
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, ".gitignore"), []byte(content), 0644)
}
func (p *TerraformPlugin) generateVariablesTf(ctx *GenerateContext) error {
	content := `# autogenerated
variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "component_name" {
  description = "Name of the component"
  type        = string
  default     = "` + ctx.Component + `"
}

variable "environment" {
  description = "Environment name"
  type        = string
}
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, "variables.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateProviderTf(ctx *GenerateContext) error {
	content := `# autogenerated
terraform {
  required_providers {
    google = {
      source = "hashicorp/google"
      version = "6.46.0"
    }

		google-beta = {
      source = "hashicorp/google-beta"
      version = "6.46.0"
    }
  }
}
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, "provider.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateBackendTf(ctx *GenerateContext) error {
	content := `# autogenerated
terraform {
  backend "gcs" {
		bucket  = "dknathalage-tf-state"
	}
}
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, "backend.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateTaskfile(ctx *GenerateContext) error {
	content := `# autogenerated
version: "3"

vars:
  COMPONENT: ` + ctx.Component + `

tasks:
`

	// Generate environment-specific tasks with proper backend initialization
	for _, env := range ctx.Environments {
		prefix := fmt.Sprintf("%s/%s/%s/%s", ctx.Org, ctx.Repo, ctx.Component, env)
		content += `  init:` + env + `:
    desc: Initialize Terraform for ` + ctx.Component + ` in ` + env + ` environment
    internal: true
    cmds:
      - terraform init -reconfigure -backend-config="prefix=` + prefix + `"

  plan:` + env + `:
    desc: Plan Terraform changes for ` + ctx.Component + ` in ` + env + ` environment
    deps: [init:` + env + `]
    cmds:
      - terraform plan -var-file="tfvars/` + env + `.tfvars"

  apply:` + env + `:
    desc: Apply Terraform changes for ` + ctx.Component + ` in ` + env + ` environment
    deps: [init:` + env + `]
    cmds:
      - terraform apply -var-file="tfvars/` + env + `.tfvars" --auto-approve

`
	}

	return os.WriteFile(filepath.Join(ctx.OutputDir, "Taskfile.yaml"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateTfvars(ctx *GenerateContext, environment string, outputDir string) error {
	filePath := filepath.Join(outputDir, environment+".tfvars")

	// Check if file already exists
	if _, err := os.Stat(filePath); err == nil {
		// File exists, skip creation
		return nil
	} else if !os.IsNotExist(err) {
		// Some other error occurred while checking file existence
		return fmt.Errorf("error checking if file exists: %w", err)
	}

	// File doesn't exist, create it
	content := `# autogenerated
component_name = "` + ctx.Component + `"
environment = "` + environment + `"
`
	return os.WriteFile(filePath, []byte(content), 0644)
}
