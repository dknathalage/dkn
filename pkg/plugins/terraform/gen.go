package terraform

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
)

func (p *TerraformPlugin) Gen(ctx context.Context, deployPath string, outputDir string) error {
	config, err := LoadConfig(deployPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	terraformDir := filepath.Join(outputDir, "terraform")
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		return fmt.Errorf("failed to create terraform directory: %w", err)
	}

	org, repo, err := p.getOrgAndRepo()
	if err != nil {
		return fmt.Errorf("failed to get org/repo: %w", err)
	}

	// Extract environment names
	var environmentNames []string
	for _, env := range config.Environments {
		environmentNames = append(environmentNames, env.Metadata.Name)
	}

	for _, component := range config.Components {
		// Use component's environments or environmentRefs if specified, otherwise use all environments
		componentEnvs := component.Spec.Environments
		if len(componentEnvs) == 0 {
			componentEnvs = component.Spec.EnvironmentRefs
		}
		if len(componentEnvs) == 0 {
			componentEnvs = environmentNames
		}

		genCtx := &GenerateContext{
			Component:    component.Metadata.Name,
			Environments: componentEnvs,
			OutputDir:    terraformDir,
			Org:          org,
			Repo:         repo,
		}
		if err := p.generateComponent(genCtx, config); err != nil {
			return fmt.Errorf("failed to generate component %s: %w", component.Metadata.Name, err)
		}
	}

	fmt.Printf("âœ… Generated Terraform configuration in %s\n", terraformDir)
	return nil
}

func (p *TerraformPlugin) generateComponent(ctx *GenerateContext, config *Config) error {
	componentDir := filepath.Join(ctx.OutputDir, ctx.Component)
	if err := os.MkdirAll(componentDir, 0755); err != nil {
		return err
	}

	tfvarsDir := filepath.Join(componentDir, "tfvars")
	if err := os.MkdirAll(tfvarsDir, 0755); err != nil {
		return err
	}

	ctx.OutputDir = componentDir

	if err := p.generateVariablesTf(ctx); err != nil {
		return err
	}

	if err := p.generateProviderTf(ctx, config); err != nil {
		return err
	}

	if err := p.generateBackendTf(ctx, config); err != nil {
		return err
	}

	if err := p.generateGitignore(ctx); err != nil {
		return err
	}

	for _, env := range ctx.Environments {
		if err := p.generateTfvars(ctx, env, tfvarsDir); err != nil {
			return err
		}
	}

	return nil
}

func (p *TerraformPlugin) generateProviderTf(ctx *GenerateContext, config *Config) error {
	content := "# autogenerated\nterraform {\n  required_providers {\n"

	// Use component-specific providers if available, otherwise use global defaults
	providers := config.Providers
	for _, component := range config.Components {
		if component.Metadata.Name == ctx.Component && len(component.Spec.Providers) > 0 {
			providers = component.Spec.Providers
			break
		}
	}

	for _, provider := range providers {
		content += fmt.Sprintf("    %s = {\n", provider.Name)
		content += fmt.Sprintf("      source = \"%s\"\n", provider.Source)
		content += fmt.Sprintf("      version = \"%s\"\n", provider.Version)
		content += "    }\n\n"
	}

	content += "  }\n}\n"

	return os.WriteFile(filepath.Join(ctx.OutputDir, "provider.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateBackendTf(ctx *GenerateContext, config *Config) error {
	content := "# autogenerated\nterraform {\n"
	
	// Use component-specific backend if available, otherwise use global default
	backend := config.Backend
	for _, component := range config.Components {
		if component.Metadata.Name == ctx.Component && component.Spec.Backend.Type != "" {
			backend = component.Spec.Backend
			break
		}
	}
	
	content += fmt.Sprintf("  backend \"%s\" {\n", backend.Type)

	for key, value := range backend.Config {
		content += fmt.Sprintf("    %s = \"%s\"\n", key, value)
	}

	content += "  }\n}\n"

	return os.WriteFile(filepath.Join(ctx.OutputDir, "backend.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateVariablesTf(ctx *GenerateContext) error {
	content := `# autogenerated
variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "component_name" {
  description = "Name of the component"
  type        = string
  default     = "` + ctx.Component + `"
}

variable "environment" {
  description = "Environment name"
  type        = string
}
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, "variables.tf"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateGitignore(ctx *GenerateContext) error {
	content := `.terraform
.terraform*
`
	return os.WriteFile(filepath.Join(ctx.OutputDir, ".gitignore"), []byte(content), 0644)
}

func (p *TerraformPlugin) generateTfvars(ctx *GenerateContext, environment string, outputDir string) error {
	filePath := filepath.Join(outputDir, environment+".tfvars")

	if _, err := os.Stat(filePath); err == nil {
		return nil
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("error checking if file exists: %w", err)
	}

	content := `# autogenerated
component_name = "` + ctx.Component + `"
environment = "` + environment + `"
`
	return os.WriteFile(filePath, []byte(content), 0644)
}